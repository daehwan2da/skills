> 이슈 #3 os/concurrency

## 동시성과 병렬성의 차이는 무엇일까?
> 동시성은 여러 작업들이 일정 시간동안 겹쳐서 수행되나, 실제로 같은 시간에 동시에 수행되지는 않는다.  
> 즉, 빠르게 context switching 을 하여 동시에 수행되는것 처럼 느껴지게 하는 것이다.  
> 이는 CPU 의 사용량, 처리량을 끌어올리기 위함이다.  
> 병렬성은 서로 독립된 task 들이 실제로 같은 순간에 동시에 작업되는 것을 의미한다. 기술적으로 여러개의 코어 혹은 프로세서가 존재해야 
> 가능한 처리이다. 

## 동기와 비동기는 무엇이고 blocking 과 non-blocking 의 차이는 무엇인가?
> 동기와 비동기는 작업의 결과에 집중하냐에 초점을 맞춘다. 동기는 작업의 결과를 기다리는 것이고, 비동기는 기다리지 않고 무작위로 어느순간에 오는 결과를 
> 처리하는 것을 의미한다. blocking과 non-blocking 은 작업의 처리에 초점을 맞춘다. blocking 은 상대 함수로 제어권이 넘어가고, 본 함수의 처리 흐름이 피 함수로 넘어간것이다.
> 반면 non-blocking은 상대 함수를 호출하고 알아서 작업을 처리하라하고, 다시 이어지는 본인의 작업 처리에 집중한다.  

### 그럼 동기/비동기와 blocking/non-blocking 의 차이는 무엇인가?
> 결과에 초점을 맞추냐 처리에 초점을 맞추냐의 차이이다. 동기/비동기는 처리의 제어권에 관계없이 피함수의 결과가 왔냐 안왔냐에 집중한다. 따라서 비동기의 경우 다른함수에 작업이 넘어가도
> 결과가 오지 않았음에도 신경을 쓰지 않는다는 것이고, 동기는 결과를 계속 해당 함수에 물어보면서 요청을 할것이다.  
> blocking/non-blocking은 처리에 초점을, 즉 제어권의 현재 위치가 중요한것이다. non-blocking의 경우에는 피함수가 작업을 수행하든, 결과가 왔든 신경 안쓰고 그냥 그대로 다음 작업을 수행하는 것이다. 
> blocking은 제어권을 호출한 함수에게 쥐어주어 내 작업 흐름이 그대로 다른함수와 합쳐지게 되는 것이다.

### 그럼 언제 어떻게 활용하나?
> 동기/blocking 의 방식은 대표적으로 Spring Web MVC 모듈이 있다. (물론 아닐때도 있다) 이는 사용자의 요청 처리를 일일이 다 수행하며 결과가 완성되는 것을 기다리고 리턴한다. 
> 비동기 방식은 대표적으로 nodeJS가 있다. 이는 event-driven 이라고 많이 사용된다. 어느 순간에 요청이 들어오면 그냥 그 요청을 event로 다른 서버에 넘기고 본인은 계속해서 자신의 일을 
> 수행하게 된다.  
> 동기/non-blocking 방식은 요청에 대한 처리는 신경쓰지않아 기다리지않고 자신의 로직을 묵묵히 수행하지만, 이 로직이 전체적으로 끝나기 전에 다른 함수로보낸 각각의 요청의 결과가 전부 
> 존재해야만 종료가 가능하다는 점이다. 대표적으로 client 의 요청을 받고 여러 분산 서버에 요청을 병렬적으로 보내고 결과를 받아 일괄적으로 client 에게 응답해주는 서버가 예시가 된다.

## race condition과 critical section은 무엇인가?
> race condition은 여러 쓰레드 혹은 프로세스가 공유되는 자원에 동시에 접근하는 상황을 말하는 것이며,  
> critical section은 이런 race condition이 발생되는 자원의 영역을 의미한다.

### 이런 critical section에서 발생하는 문제들에 대한 해결 조건은 무엇이 있을까?
> 첫째로 공유 자원을 한 프로세스가 사용중인 경우에는 다른 프로세스의 접근을 불허한다.  
> 둘째로 한 자원이 비어있다면 다른 프로세스가 사용 가능해야한다.  
> 셋째로 프로세스가 무한정 대기하는 상황이 발생해서는 안된다.

## Semaphore와 Mutex 는 무엇이고, 어떤 차이가 있나?
> 둘 다 동기화를 해결하기 위한 메커니즘이지만, 둘의 차이는 여러 프로세스에 대해 동기화 상황에 어떻게 처리해줄까에 있다.
> Mutex같은 경우는 단순히 해당 자원에 대해 lock 을 선언하는 것이며, semaphore는 주어진 자원의 수에맞춰 프로세스들의 대기상태를 정해주고, 깨워주는 형식이다.  
> 또한 semaphore 의 한 종류로 binary semaphore 는 mutex 와 같이 한 자원에 대해 접근 가능과 불가능 두가지 경우로 동기화를 관리한다.

### semaphore 의 동작원리?
> binary semaphore 같은 경우는 하나의 정수를 통해 lock 과같은 형식으로 프로세스의 접근을 제어하는 방식이고, counting semaphore 의 경우에는  
> 자원의 수에 맞춰 semaphote integer를 생성하고, 프로세스가 접근하면 자원의 수를 하나씩 줄여주며, 자원의 수가 0이 되면 후에 접근하는 프로세스들에게  
> sleep 을 시킨다. 마찬가지로 프로세스가 완료되면 자원을 반납하고, 이때 자고있는 프로세스를 깨우며 동기화작업이 수행된다.  

### Counting semaphore 에서 발생할 수 있는 문제점은?
> 우선 정수로 표현된 자원의 수에 대해 오류가 발생하면 안된다. 만약 프로세스가 진입하는 과정에서 자원의 수가 잘못빼졌다면, 후에 기존 프로세스는 탈출하지 못하고, 새로운 프로세스는 
> 접근하지 못하는 dead lock 에 빠질수 있으며, 마찬가지로 반납을 잘못해서 자원의 수가 더해지지 않았다면 여러 프로세스가 동시에 자원에 접근해서 상호배제성을 지키지못해 
> 동기화가 이루어지지 못할것이다.

## 다른 방식의 동기화 처리 기법은 무엇이 있나?
> semaphore 외에 spinlock 방식도 존재한다. spinlock 은 프로세스가 critical section에대해 lock을 걸고 다른 프로세스가 접근하면 loop 를 돌면서 반복해서 사용이 가능한지 물어보고 
> lock 이 풀리면 접근하는 방식이다.

### busy waiting 은 무엇이고, spinlock과 어떤 관계일까?
> busy waiting 이라는 개념이 마찬가지로 loop를 돌면서 특정 탈출 조건이 만족되는지 지속적으로 확인하는 방식인데, spinlock은 그 조건이 자원의 lock 여부가 될것이다.  

### spinlock 의 문제점은?
> spinlock 은 구현이 단순하고 semaphore에 비해 context switching overhead가 없다는 장점이 있지만, loop 를 돌면서 cpu 를 점유하게 되고, 이때 낮은 우선순위를 갖는 프로세스가 지속적으로 cpu 를 점유하여 
> 높은 우선순위의 작업이 cpu 할당을 받지 못하는 경우가 있을 수 있다.

### spinlock은 언제 활용하면 좋을까?
> 공유되는 자원의 경합이 심하지 않을경우 혹은 경합이 발생하더라도 빠르게 lock 이 풀리는 자원들에 대해서 spinlock 이 활용된다.

## semaphore를 활용해 해결한 고전문제는?
> bounded buffer problem, 여러개의 프로세스를 어떻게 동기화 시킬것인가? 에대한 문제  
> reader-writer problem, 여러 reader 와 writer 가 한 buffer를 공유하며 발생하는 문제   
> dining philosophers problem, starvation 과 deadlock 에 대한 문제  

