> 이슈 #2 : Spring/transaction

## Transaction 은 무엇이고, 어떤 속성을 갖는가?
> transaction 은 하나의 요청으로 인해 단일한 작업으로 처리되어야할 연관된 작업들의 집합으로,  
> 단일한 작업내의 여러 작업들의 모든 결과가 전부 반영되거나, 전부 취소되도록 하는 하나의 논리적인 작업의 단위이다.  
> 이를 통해서 데이터의 무결성, 정합성을 보장한다.
> 속성으로는 ACID 가 존재한다.  
> A (atomic, 원자성) : 트랜잭션 내 모든 작업단위가 전부 반영되거나, 전부 반영되지 않는 성질을 의미한다.
> C (consistency, 일관성): 데이터가 갖는 속성은 일관되어야한다는 것을 의미한다. 즉 int였던 데이터가 String이 될수 없다는 의미이다.
> I (isolation, 고립성): 각 트랜잭션은 독립적이고, 고립되어야한다. 즉 서로간에 간섭이 존재해서는 안된다.
> D (Durability, 영구성): 한번 반영된 트랜잭션은 변함없어야한다.

### 무결성과 정합성의 차이는?
> 무결성은 데이터가 정확하게 존재해야한다는 것을 의미한다. 예를 들어 참조 무결성을 생각해보면, FK의 데이터가 없는 상태라면  
> 데이터가 정확하게 존재하지 않음을 의미하므로, 이는 참조 무결성 제약조건에 위배된다.  
> 정합성은 데이터가 모두에게 일치된 값을 제공하는것을 의미한다. 즉, 어떤 트랜잭션에서 같은 데이터에 접근하더라도 일치된 값이 보장되어야한다는 의미이다.  

## Transaction에서 데이터의 충돌, 동기화등은 어떻게 해결하는가?
> RDB에 있어 가장 핵심적이고 어려운 부분이다. 
> Transaction은 4단계의 격리수준을 제공하여 해당 문제를 해결하려고한다.
> 1) read uncommited : 두 트랜잭션간에 커밋이되지 않은 값에 대해서도 서로 접근이 가능한 단계이다.
> 이는 가장 느슨한 단계로, Dirty read 문제가 발생할 수 있다.
> 2) read commited : 커밋이 된 값에 대해서만 다른 트랜잭션이 접근할 수 있다. 이는 repeatable read 문제를 발생할 수 있다.
> 3) non-repeatable read : 트랜잭션이 끝나기 전까지는 다른 트랜잭션에 의해 커밋된 값에 접근하지 않고, undo 로그의 값에만 접근하도록한다. 
> 4) serializable : phantom read 를 해결한다. 이는 가장 강력한 격리수준으로, 모든 데이터의 접근에 대해 locking 이 작동하고, 이는 성능상 큰 저하를 일으킨다.
> 중요한 것은 성능과 데이터간의 적절한 trade-off가 필요하다는 것이다.

### Dirty Read, repeatable read?
> Dirty Read : 커밋되지 않은 값에 대해 접근하게되고, 롤백이되어 값이 기존값으로 변경되었을때 접근된 값이 정합성을 잃는것을 의미한다.
> repeatable read : 커밋된 값에 대해서만 접근이 가능하게 되는데, 한 트랜잭션이 커밋전의 값을 조회하고 끝나지 않은 상태에서 커밋이 발생해
> 다시 값을 접근했을때, 트랜잭션이 끝나지 않은 상태에서의 두 조회 결과 값이 서로 상이하여 정합성을 잃는 것을 의미한다.

## Spring 에서의 Transaction?
> Spring framework 는 transaction 관리에 있어 일관성있는 추상화를 제공한다. 또한 선언적 트랜잭션을 바탕으로 여러 설정들이 커스터마이징가능하다.
> 즉, 로직 내에서 트랜잭션의 전이에 대한 설정, 격리수준 등을 옵션으로 설정할 수 있다.

### Spring 에서 어떤 예외가 발생했을때 transaction이 roll back 되는가?
> 어떤 예외인지에 따라서 커스텀이 가능하며, 별다른 설정이 없다면 unchecked exception 에 대해서 roll back 을 수행한다. 

(* 중요)
### Spring 에서 @Transactional 의 동작 원리는?
> 우선 Spring AOP에서 기본적으로 CGLIB를 통해 Proxy 인스턴스를 생성하게 되고, 이때 해당 클래스를 상속받아 Proxy 인스턴스를 생성하며,
> 어노테이션이 적용된 메서드들에 한해 transaction 작업이 감싸지게된다. 이때 private 메서드에 대해서는 적용되지 않는다.  
> 설정한 예외 (없다면 unchecked exception)가 발생하면 try catch 를 통해 롤백을 수행하게 된다.

### 왜 private 메서드에 대해서는 적용되지 않는가?
> CGLIB 는 Proxy 객체 생성시 상속을 사용하게 되는데, 상속의 특성상 private 접근제어자에 대해서는 접근이 불가능하게 되기 때문이다.

### 같은 Bean 내에서 내부 호출한 메서드에 대해서 @Transactional 이 적용이 되는가?
> 적용되지 않는다. 이유는 Proxy 객체 생성시 @Transactional 이 붙은 메서드들에 적용이 되는데, 이때 메서드 내부에는 적용되지 않으므로 
> 메서드 내에서의 내부적인 호출에는 별도의 트랜잭션이 생성되지 않는다.

### 그럼 @Transactional(REQUIRED_NEW) 는 의미 없는 트랜잭션 상태 전이인가?
> 아니다. 위에서 말한 트랜잭션 생성이 안되는 부분은 메서드 내에서 같은 빈의 메서드 호출에 의한 것을 의미하며,
> 만약 서로 다른 빈에 대해서는 호출시에 REQUIRED_NEW 조건이 있다면 새로운 트랜잭션이 생성되어지는것으로 알고있다.

### 자식 트랜잭션에서 예외가 발생하면 부모 트랜잭션은 어떻게 처리되어지는가?
> 별다른 로직을 추가해주지 않는다면, 예외발생으로 처리되어 부모 트랜잭션에서도 롤백이 수행된다. 허나 부모 트랜잭션에서 예외가 발생한것에 대해서는 
> 자식 트랜잭션은 영향을 받지 않아 자식은 커밋이 수행된다.

## 분산 트랜잭션에 대한 소개와 대처방법은?
> MSA 에 있어 대처하기 어려운 부분 중 하나로 생각된다. 
> 요칭이 적고 트랜잭션이 단순할때에는 크게 고민하지 않은 부분이나, 요청이 많아지고 트랜잭션이 복잡해지고 커지면서 중요하게 처리되어야하는 메커니즘입니다.
> 가장 대표적으로 2가지를 설명
> 1. two-phase commit : 고전적인 방법으로, 두가지 phase를 나누어 전체적인 트랜잭션의 커밋을 수행한다. 
> 준비 단계와 커밋 단계로 나눌 수 있으며, 준비 단계에는 각 트랜잭션에게 커밋이 가능한 상태인지 일일이 물어보고 준비상태를 확인하며,
> 준비가 완료되면 전체적인 커밋이 수행되는 방법이다. 이는 하나의 로직에서 수행되며 가장 단점으로 동기적인 수행이라는 점이다.
> 데이터에 대한 ACID는 보장되지만, MSA 환경에서 성능 저하의 원인이되기도 하며 단일 장애지점이 될 수도있다.
> 2. saga pattern : long-running transaction에 대해 여러 작은 작업(프로세스)들로 분할하여 각각을 독립적으로 수행하도록한다.
> 따라서 각 트랜잭션이 수행이 완료되면 커밋, 그렇지 않으면 롤백되는 것이 독립적으로 발생된다. 일괄적인 롤백을 명령하지 못하게된다.
> 대신 처음에 보상 트랜잭션을 생성하여 만약 한 트랜잭션에서 failure가 발생된다면, 기존 커밋된 트랜잭션들에게 보상트랜잭션을 수행해
> 수동적인 롤백작업을 수행하게된다. 이는 비동기적으로 처리되는 환경에서 성능의 지장을 받지 않게되지만, 완벽한 트랜잭션 처리가 되지는 못한다.




